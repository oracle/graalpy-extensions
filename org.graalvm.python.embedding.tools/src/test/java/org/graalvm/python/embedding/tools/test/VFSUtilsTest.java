/*
 * Copyright (c) 2025, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * The Universal Permissive License (UPL), Version 1.0
 *
 * Subject to the condition set forth below, permission is hereby granted to any
 * person obtaining a copy of this software, associated documentation and/or
 * data (collectively the "Software"), free of charge and under any and all
 * copyright rights in the Software, and any and all patent rights owned or
 * freely licensable by each licensor hereunder covering either (i) the
 * unmodified Software as contributed to or provided by such licensor, or (ii)
 * the Larger Works (as defined below), to deal in both
 *
 * (a) the Software, and
 *
 * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if
 * one is included with the Software each a "Larger Work" to which the Software
 * is contributed by such licensors),
 *
 * without restriction, including without limitation the rights to copy, create
 * derivative works of, display, perform, and distribute the Software and make,
 * use, sell, offer for sale, import, export, have made, and have sold the
 * Software and the Larger Work(s), and to sublicense the foregoing rights on
 * either these or other terms.
 *
 * This license is subject to the following condition:
 *
 * The above copyright notice and either this complete permission notice or at a
 * minimum a reference to the UPL must be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package org.graalvm.python.embedding.tools.test;

import org.graalvm.python.embedding.tools.exec.BuildToolLog;
import org.graalvm.python.embedding.tools.vfs.VFSUtils;
import org.graalvm.python.embedding.tools.vfs.VFSUtils.PackagesChangedException;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.function.Executable;

import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static org.graalvm.python.embedding.tools.test.EmbeddingTestUtils.createLauncher;
import static org.graalvm.python.embedding.tools.test.EmbeddingTestUtils.deleteDirOnShutdown;
import static org.junit.jupiter.api.Assertions.*;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.containsString;
import static org.hamcrest.Matchers.not;

public class VFSUtilsTest {

	private static final String GRAALPY_VERSION_PREFIX;
	private static final String INPUT_PACKAGES_PREFIX;

	static {
		try {
			Field f = VFSUtils.class.getDeclaredField("GRAALPY_VERSION_PREFIX");
			f.setAccessible(true);
			GRAALPY_VERSION_PREFIX = (String) f.get(VFSUtils.class);
			f = VFSUtils.class.getDeclaredField("INPUT_PACKAGES_PREFIX");
			f.setAccessible(true);
			INPUT_PACKAGES_PREFIX = (String) f.get(VFSUtils.class);
		} catch (NoSuchFieldException | IllegalAccessException e) {
			throw new RuntimeException(e);
		}
	}

	private static final String PACKAGE_WAS_REMOVED = "A package with transitive dependencies was removed since last install, setting up a clean venv";
	private static final String LOCK_FILE_HEADER = "generated by graalpy tests\nwith a two line header";
	private static final String MISSING_LOCK_FILE_WARNING = "missing lock file";
	private static final String STALE_VENV = "Stale GraalPy virtual environment, updating to";

	private static final class TestLog implements BuildToolLog {
		private final StringBuilder output = new StringBuilder();

		private void addLine(String s) {
			this.output.append('\n').append(s);
		}

		private void clearOutput() {
			output.delete(0, output.length());
		}

		public void subProcessOut(String s) {
			println("[subout] ", s);
			addLine(s.toString());
		}

		public void subProcessErr(String s) {
			println("[suberr] ", s);
			addLine(s.toString());
		}

		public void info(String s) {
			println("[info] ", s);
			addLine(s);
		}

		public void warning(String s) {
			println("[warn] ", s);
			addLine(s);
		}

		public void warning(String s, Throwable t) {
			println("[warn] ", s);
			t.printStackTrace();
			addLine(s);
		}

		public void error(String s) {
			println("[err] ", s);
			addLine(s);
		}

		@Override
		public void debug(String s) {
			println("[debug] ", s);
			addLine(s);
		}

		@Override
		public boolean isWarningEnabled() {
			return true;
		}

		@Override
		public boolean isInfoEnabled() {
			return true;
		}

		@Override
		public boolean isErrorEnabled() {
			return true;
		}

		@Override
		public boolean isSubprocessOutEnabled() {
			return true;
		}

		@Override
		public boolean isDebugEnabled() {
			return isVerbose();
		}

		public String getOutput() {
			return output.toString();
		}

		static void println(String... args) {
			if (isVerbose()) {
				System.out.println(String.join(" ", args));
			}
		}

		private static boolean isVerbose() {
			return Boolean.getBoolean("com.oracle.graal.python.test.verbose");
		}
	}

	/**
	 * tests scenarios without lock file logic available, but not used
	 *
	 * - packages declared only in plugin config - lock file path is provided, but
	 * does not exist
	 */
	@Test
	public void withPackagesOnlyFromPluginConfig() throws IOException, PackagesChangedException {
		TestLog log = new TestLog();
		Path tmpDir = Files.createTempDirectory("withPackagesOnlyFromPluginConfig");
		Path venvDir = tmpDir.resolve("venv");
		deleteDirOnShutdown(tmpDir);

		// test with a not existing lock file path
		// the maven and gradle plugins always send the default lock file path, no
		// matter if the
		// file exists or not
		Path lockFile = tmpDir.resolve("lockFile.txt");
		Path contents = venvDir.resolve("contents");

		// no packages, lock file file does not exist - does nothing
		log.clearOutput();
		createVenv(venvDir, "0.1", log, lockFile);
		assertFalse(Files.exists(venvDir));
		checkVenvCreate(log.getOutput(), false);
		assertThat(log.getOutput(), not(containsString("pip install")));

		log.clearOutput();

		// install packages
		log.clearOutput();
		createVenv(venvDir, "0.1", log, lockFile, "hello-world", "tiny-tiny");
		assertTrue(Files.exists(venvDir));
		checkVenvCreate(log.getOutput(), true);
		assertThat(log.getOutput(), containsString("pip install"));
		assertThat(log.getOutput(), containsString(MISSING_LOCK_FILE_WARNING));
		checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world", "tiny-tiny");
		checkVenvContentsFile(contents, "0.1", "hello-world", "tiny-tiny");

		// install packages again, assert that venv wasn't created again and packages
		// weren't
		// installed
		log.clearOutput();
		createVenv(venvDir, "0.1", log, lockFile, "hello-world", "tiny-tiny");
		assertTrue(Files.exists(venvDir));
		checkVenvCreate(log.getOutput(), false);
		assertFalse(log.getOutput().contains("pip install"));
		assertThat(log.getOutput(), not(containsString("hello-world")));
		assertThat(log.getOutput(), not(containsString("tiny-tiny")));
		assertTrue(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
		checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world", "tiny-tiny");
		checkVenvContentsFile(contents, "0.1", "hello-world", "tiny-tiny");

		// remove tiny-tiny, assert that venv was deleted and created anew as we don't
		// know if there
		// were any transitive deps left
		log.clearOutput();
		createVenv(venvDir, "0.1", log, lockFile, "hello-world");
		assertTrue(Files.exists(venvDir));
		checkVenvCreate(log.getOutput(), true);
		assertThat(log.getOutput(), containsString(PACKAGE_WAS_REMOVED));
		assertTrue(log.getOutput().contains("pip install"));
		assertTrue(log.getOutput().contains("hello-world"));
		assertFalse(log.getOutput().contains("tiny-tiny"));
		assertTrue(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
		checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world");
		checkVenvContentsFile(contents, "0.1", "hello-world");

		// install only hello-world again, assert that venv wasn't created and
		// packages weren't installed
		log.clearOutput();
		createVenv(venvDir, "0.1", log, lockFile, "hello-world==0.2");
		assertTrue(Files.exists(venvDir));
		checkVenvCreate(log.getOutput(), false);
		assertTrue(log.getOutput().contains("pip install"));
		assertThat(log.getOutput(), containsString("pip uninstall"));
		assertTrue(log.getOutput().contains("hello-world"));
		assertThat(log.getOutput(), not(containsString(MISSING_LOCK_FILE_WARNING)));
		checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world");
		checkVenvContentsFile(contents, "0.1", "hello-world==0.2");
	}

	/**
	 * tests scenarios without lock file logic - e.g. when called from jbang
	 *
	 * - packages declared only in plugin config - and lock file path is not
	 * provided
	 */
	@Test
	public void withoutLockFile() throws IOException, PackagesChangedException {
		TestLog log = new TestLog();
		Path tmpDir = Files.createTempDirectory("withoutLockFile");
		Path venvDir = tmpDir.resolve("venv");
		Path contents = venvDir.resolve("contents");
		deleteDirOnShutdown(tmpDir);

		createVenv(venvDir, "0.1", log);
		assertFalse(Files.exists(venvDir));
		checkVenvCreate(log.getOutput(), false);
		assertFalse(log.getOutput().contains("pip install"));
		assertThat(log.getOutput(), not(containsString(MISSING_LOCK_FILE_WARNING)));
		log.clearOutput();

		createVenv(venvDir, "0.1", log, "hello-world==0.1");
		assertTrue(Files.exists(venvDir));
		checkVenvCreate(log.getOutput(), true);
		assertFalse(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
		checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world");
		checkVenvContentsFile(contents, "0.1", "hello-world==0.1");
		log.clearOutput();

		createVenv(venvDir, "0.1", log, "hello-world==0.1", "tiny-tiny");
		assertTrue(Files.exists(venvDir));
		checkVenvCreate(log.getOutput(), false);
		assertFalse(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
		checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world", "tiny-tiny");
		checkVenvContentsFile(contents, "0.1", "hello-world==0.1", "tiny-tiny");
		log.clearOutput();

		createVenv(venvDir, "0.1", log, "hello-world==0.1");
		assertTrue(Files.exists(venvDir));
		checkVenvCreate(log.getOutput(), true);
		assertFalse(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
		checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world");
		checkVenvContentsFile(contents, "0.1", "hello-world==0.1");
		log.clearOutput();
	}

	@Test
	public void lockFile() throws IOException {
		TestLog log = new TestLog();
		Path tmpDir = Files.createTempDirectory("emptyLockFile");
		Path venvDir = tmpDir.resolve("venv");
		deleteDirOnShutdown(tmpDir);

		Path lockFile = tmpDir.resolve("graalpy.lock");

		Files.createFile(lockFile);

		createWithLockFile(venvDir, lockFile, log);

		List<String> validLockFileHeader = createLockFileHeader("0.1", "pkg");

		List<String> lockFileList;
		int headerLineCount = LOCK_FILE_HEADER.split("\n").length;

		// bogus graalPyVersion line
		int graalpVersionLineIdx = headerLineCount;
		lockFileList = new ArrayList<>(validLockFileHeader);
		lockFileList.set(graalpVersionLineIdx, "test");
		createWithLockFile(venvDir, lockFile, log, lockFileList);

		// empty graalPyVersion line
		lockFileList = new ArrayList<>(validLockFileHeader);
		lockFileList.set(graalpVersionLineIdx, GRAALPY_VERSION_PREFIX);
		createWithLockFile(venvDir, lockFile, log, lockFileList);
		lockFileList = new ArrayList<>(validLockFileHeader);
		lockFileList.set(graalpVersionLineIdx, GRAALPY_VERSION_PREFIX + "   ");
		createWithLockFile(venvDir, lockFile, log, lockFileList);

		// bogus input packages line
		lockFileList = new ArrayList<>(validLockFileHeader);
		lockFileList.set(3, "test");
		createWithLockFile(venvDir, lockFile, log, lockFileList);

		// empty input packages line
		lockFileList = new ArrayList<>(validLockFileHeader);
		lockFileList.set(3, INPUT_PACKAGES_PREFIX);
		createWithLockFile(venvDir, lockFile, log, lockFileList);
		lockFileList = new ArrayList<>(validLockFileHeader);
		lockFileList.set(3, INPUT_PACKAGES_PREFIX + "   ");
		createWithLockFile(venvDir, lockFile, log, lockFileList);
	}

	private static void createWithLockFile(Path venvDir, Path lockFile, TestLog log, List<String> lines)
			throws IOException {
		createWithLockFile(venvDir, lockFile, log, lines.toArray(new String[lines.size()]));
	}

	private static void createWithLockFile(Path venvDir, Path lockFile, TestLog log, String... lines)
			throws IOException {
		Files.write(lockFile, new ArrayList<>(Arrays.asList(lines)), StandardOpenOption.CREATE,
				StandardOpenOption.TRUNCATE_EXISTING);
		checkException(IOException.class, () -> createVenv(venvDir, "0.1", log, lockFile),
				"Cannot read the lock file from ");
		assertFalse(Files.exists(venvDir));
		checkVenvCreate(log.getOutput(), false);
		assertFalse(log.getOutput().contains("pip install"));
		log.clearOutput();
	}

	private static void lock(Path venvDir, Path lockFile, TestLog log, String... packages) throws IOException {
		VFSUtils.lockPackages(venvDir, Arrays.asList(packages), lockFile, LOCK_FILE_HEADER, createLauncher(venvDir),
				"0.1", log);
	}

	private static List<String> createLockFileHeader(String graalPyVersion, String... packages) {
		List<String> lines = new ArrayList<>();
		for (String s : LOCK_FILE_HEADER.split("\n")) {
			lines.add("# " + s);
		}
		lines.add(GRAALPY_VERSION_PREFIX + graalPyVersion);
		lines.add(INPUT_PACKAGES_PREFIX + String.join(",", packages));
		return lines;
	}

	@Test
	public void installAndLock() throws IOException, PackagesChangedException {
		TestLog log = new TestLog();
		Path tmpDir = Files.createTempDirectory("installAndLock");
		Path venvDir = tmpDir.resolve("venv");
		Path contents = venvDir.resolve("contents");
		deleteDirOnShutdown(tmpDir);

		Path lockFile = tmpDir.resolve("graalpy.lock");

		// install request from plugin config, it pulls in transitive pkgs, and
		// we get the missing lock file warning
		createVenv(venvDir, "0.1", log, lockFile, "requests");
		assertTrue(Files.exists(venvDir));
		checkVenvCreate(log.getOutput(), true);
		checkInstalledPackages(venvDir.resolve("installed.txt"), "requests", "charset-normalizer", "idna", "urllib3",
				"certifi");
		checkVenvContentsFile(contents, "0.1", "requests");
		assertTrue(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
		log.clearOutput();

		// lock without version
		lock(venvDir, lockFile, log, "requests");
		assertTrue(Files.exists(lockFile));
		assertFalse(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
		// lock with version
		Files.delete(lockFile);
		lock(venvDir, lockFile, log, "requests==2.32.2");
		checkLockFile(lockFile, new String[]{"requests==2.32.2"}, "requests==2.32.2", "charset-normalizer", "idna",
				"urllib3", "certifi");
		checkVenvContentsFile(contents, "0.1", "requests==2.32.2");
		assertFalse(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
		log.clearOutput();

		// reinstall without exact version declared - fails
		checkException(PackagesChangedException.class, () -> createVenv(venvDir, "0.1", log, lockFile, "requests"));
		checkVenvCreate(log.getOutput(), false);
		assertFalse(log.getOutput().contains("pip install"));
		checkInstalledPackages(venvDir.resolve("installed.txt"), "requests==2.32.2", "charset-normalizer", "idna",
				"urllib3", "certifi");
		checkVenvContentsFile(contents, "0.1", "requests==2.32.2");
		assertFalse(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
		log.clearOutput();

		// reinstall again - no more warning
		EmbeddingTestUtils.delete(venvDir);
		createVenv(venvDir, "0.1", log, lockFile, "requests==2.32.2");
		assertTrue(Files.exists(venvDir));
		checkVenvCreate(log.getOutput(), true);
		checkInstalledPackages(venvDir.resolve("installed.txt"), "requests==2.32.2", "charset-normalizer", "idna",
				"urllib3", "certifi");
		checkVenvContentsFile(contents, "0.1", "requests==2.32.2");
		assertFalse(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
		log.clearOutput();

		// reinstall with lower version - ok
		Files.delete(lockFile);
		createVenv(venvDir, "0.1", log, lockFile, "requests==2.32.1");
		// we changed version from 2.32.2 to 2.32.1, we do not know if the prev version
		// did not
		// leave
		// any transitive deps, so the venv is deleted and created again
		checkVenvCreate(log.getOutput(), true);
		assertThat(log.getOutput(), containsString("pip install"));
		checkInstalledPackages(venvDir.resolve("installed.txt"), "requests==2.32.1", "charset-normalizer", "idna",
				"urllib3", "certifi");
		checkVenvContentsFile(contents, "0.1", "requests==2.32.1");
		assertTrue(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
		log.clearOutput();
		// lock
		lock(venvDir, lockFile, log, "requests==2.32.1");
		checkLockFile(lockFile, new String[]{"requests==2.32.1"}, "requests==2.32.1", "charset-normalizer", "idna",
				"urllib3", "certifi");
		checkInstalledPackages(venvDir.resolve("installed.txt"), "requests==2.32.1", "charset-normalizer", "idna",
				"urllib3", "certifi");
		assertThat(log.getOutput(), not(containsString(MISSING_LOCK_FILE_WARNING)));
		log.clearOutput();

		// add tiny-tiny - fails because inconsistent with lock file
		assert Files.exists(lockFile);
		checkException(PackagesChangedException.class,
				() -> createVenv(venvDir, "0.1", log, lockFile, "requests==2.32.1", "tiny-tiny==0.2"));
		checkVenvCreate(log.getOutput(), false);
		assertFalse(log.getOutput().contains("pip install"));
		checkInstalledPackages(venvDir.resolve("installed.txt"), "requests==2.32.1", "charset-normalizer", "idna",
				"urllib3", "certifi");
		checkVenvContentsFile(contents, "0.1", "requests==2.32.1");
		assertFalse(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
		log.clearOutput();

		// delete lock and try again tiny-tiny - now ok
		Files.delete(lockFile);
		createVenv(venvDir, "0.1", log, lockFile, "requests==2.32.1", "tiny-tiny==0.2");
		checkVenvCreate(log.getOutput(), false);
		assertTrue(log.getOutput().contains("pip install"));
		checkInstalledPackages(venvDir.resolve("installed.txt"), "requests==2.32.1", "tiny-tiny==0.2",
				"charset-normalizer", "idna", "urllib3", "certifi");
		checkVenvContentsFile(contents, "0.1", "requests==2.32.1", "tiny-tiny==0.2");
		assertThat(log.getOutput(), containsString(MISSING_LOCK_FILE_WARNING));
		log.clearOutput();
		// lock
		lock(venvDir, lockFile, log, "requests==2.32.1", "tiny-tiny==0.2");
		checkLockFile(lockFile, new String[]{"requests==2.32.1", "tiny-tiny==0.2"}, "requests==2.32.1",
				"tiny-tiny==0.2", "charset-normalizer", "idna", "urllib3", "certifi");
		checkInstalledPackages(venvDir.resolve("installed.txt"), "requests==2.32.1", "tiny-tiny==0.2",
				"charset-normalizer", "idna", "urllib3", "certifi");
		assertFalse(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
		log.clearOutput();

		// install again - OK
		createVenv(venvDir, "0.1", log, lockFile, "requests==2.32.1", "tiny-tiny==0.2");
		checkVenvCreate(log.getOutput(), false);
		assertThat(log.getOutput(), not(containsString("pip install")));
		checkInstalledPackages(venvDir.resolve("installed.txt"), "requests==2.32.1", "tiny-tiny==0.2",
				"charset-normalizer", "idna", "urllib3", "certifi");
		checkVenvContentsFile(contents, "0.1", "requests==2.32.1", "tiny-tiny==0.2");
		assertThat(log.getOutput(), not(containsString(MISSING_LOCK_FILE_WARNING)));
		log.clearOutput();

		// update in declared packages requests version back to 2.32.2 - fails
		checkException(PackagesChangedException.class,
				() -> createVenv(venvDir, "0.1", log, lockFile, "requests==2.32.2", "tiny-tiny==0.2"));
		checkVenvCreate(log.getOutput(), false);
		assertFalse(log.getOutput().contains("pip install"));
		checkInstalledPackages(venvDir.resolve("installed.txt"), "requests==2.32.1", "tiny-tiny==0.2",
				"charset-normalizer", "idna", "urllib3", "certifi");
		checkVenvContentsFile(contents, "0.1", "requests==2.32.1", "tiny-tiny==0.2");
		assertFalse(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
		log.clearOutput();

		// delete lock and try again new hello-world version - now ok
		Files.delete(lockFile);
		createVenv(venvDir, "0.1", log, lockFile, "requests==2.32.2", "tiny-tiny==0.2");
		// we changed version from 2.32.2 to 2.32.1, we do not know if the prev version
		// did not
		// leave
		// any transitive deps, so the venv is deleted and created again
		checkVenvCreate(log.getOutput(), true);
		assertThat(log.getOutput(), containsString("pip install"));
		checkInstalledPackages(venvDir.resolve("installed.txt"), "requests==2.32.2", "tiny-tiny==0.2",
				"charset-normalizer", "idna", "urllib3", "certifi");
		checkVenvContentsFile(contents, "0.1", "requests==2.32.2", "tiny-tiny==0.2");
		assertTrue(log.getOutput().contains(MISSING_LOCK_FILE_WARNING));
		log.clearOutput();
		// lock with new requests version
		lock(venvDir, lockFile, log, "requests==2.32.2", "tiny-tiny==0.2");
		checkInstalledPackages(venvDir.resolve("installed.txt"), "requests==2.32.2", "tiny-tiny==0.2",
				"charset-normalizer", "idna", "urllib3", "certifi");
		checkLockFile(lockFile, new String[]{"requests==2.32.2", "tiny-tiny==0.2"}, "requests==2.32.2",
				"tiny-tiny==0.2", "charset-normalizer", "idna", "urllib3", "certifi");
		assertThat(log.getOutput(), not(containsString(MISSING_LOCK_FILE_WARNING)));
		log.clearOutput();

		// install again - OK
		createVenv(venvDir, "0.1", log, lockFile, "requests==2.32.2", "tiny-tiny==0.2");
		checkVenvCreate(log.getOutput(), false);
		assertThat(log.getOutput(), not(containsString("pip install")));
		checkInstalledPackages(venvDir.resolve("installed.txt"), "requests==2.32.2", "tiny-tiny==0.2",
				"charset-normalizer", "idna", "urllib3", "certifi");
		checkLockFile(lockFile, new String[]{"requests==2.32.2", "tiny-tiny==0.2"}, "requests==2.32.2",
				"tiny-tiny==0.2", "charset-normalizer", "idna", "urllib3", "certifi");
		checkVenvContentsFile(contents, "0.1", "requests==2.32.2", "tiny-tiny==0.2");
		assertThat(log.getOutput(), not(containsString(MISSING_LOCK_FILE_WARNING)));
		log.clearOutput();

		// remove requests from packages list - fails because it is still in lock
		checkException(PackagesChangedException.class,
				() -> createVenv(venvDir, "0.1", log, lockFile, "tiny-tiny==0.2"));
		checkVenvCreate(log.getOutput(), false);
		assertFalse(log.getOutput().contains("pip install"));
		log.clearOutput();
		// lock only with tiny-tiny
		lock(venvDir, lockFile, log, "tiny-tiny==0.2");
		checkVenvCreate(log.getOutput(), true);
		checkLockFile(lockFile, new String[]{"tiny-tiny==0.2"}, "tiny-tiny==0.2");
		// requests transitive deps are gone as well
		checkInstalledPackages(venvDir.resolve("installed.txt"), "tiny-tiny==0.2");
		checkVenvContentsFile(contents, "0.1", "tiny-tiny==0.2");
		assertThat(log.getOutput(), not(containsString(MISSING_LOCK_FILE_WARNING)));
		log.clearOutput();
		// try again
		createVenv(venvDir, "0.1", log, lockFile, "tiny-tiny==0.2");
		checkVenvCreate(log.getOutput(), false);
		assertThat(log.getOutput(), not(containsString("pip install")));
		assertThat(log.getOutput(), containsString("Virtual environment is up to date with lock file"));
		log.clearOutput();

		// reinstall with new graalpy version
		createVenv(venvDir, "0.2", log, lockFile, "tiny-tiny==0.2");
		checkVenvCreate(log.getOutput(), true);
		assertThat(log.getOutput(), containsString(STALE_VENV));
		assertThat(log.getOutput(), containsString("pip install --compile -r")); // lock file is used
		checkInstalledPackages(venvDir.resolve("installed.txt"), "tiny-tiny==0.2");
		checkVenvContentsFile(contents, "0.2", "tiny-tiny==0.2");
		assertThat(log.getOutput(), not(containsString(MISSING_LOCK_FILE_WARNING)));
		log.clearOutput();
	}

	@Test
	public void packageRemoved()
			throws InvocationTargetException, NoSuchMethodException, IllegalAccessException, IOException {
		Path tmpDir = Files.createTempDirectory("packageRemoved");
		deleteDirOnShutdown(tmpDir);

		assertFalse(callPackageRemoved(Collections.emptyList(), Collections.emptyList(), Collections.emptyList()));
		assertFalse(callPackageRemoved(Arrays.asList("pkg1"), Collections.emptyList(), Collections.emptyList()));
		assertFalse(callPackageRemoved(Arrays.asList("pkg1"), Arrays.asList("pkg1"), Arrays.asList("pkg1==1")));
		assertFalse(callPackageRemoved(Arrays.asList("pkg1", "pkg2"), Arrays.asList("pkg1"), Arrays.asList("pkg1==1")));
		assertFalse(callPackageRemoved(Arrays.asList("pkg1", "pkg2"), Arrays.asList("pkg1", "pkg2"),
				Arrays.asList("pkg1==1", "pkg2==1")));

		assertFalse(callPackageRemoved(Arrays.asList("pkg1=="), Arrays.asList("pkg1=="), Arrays.asList("pkg1==1")));
		assertFalse(callPackageRemoved(Arrays.asList("==pkg1"), Arrays.asList("==pkg1"), Arrays.asList("pkg1==1")));
		assertFalse(callPackageRemoved(Arrays.asList("pkg1==1"), Arrays.asList("pkg1"), Arrays.asList("pkg1==1")));
		assertFalse(callPackageRemoved(Arrays.asList("pkg1"), Arrays.asList("pkg1"), Arrays.asList("pkg1==1")));

		assertTrue(callPackageRemoved(Collections.emptyList(), Arrays.asList("pkg"), Arrays.asList("pkg==1")));
		assertTrue(callPackageRemoved(Arrays.asList("pkg2"), Arrays.asList("pkg1"), Arrays.asList("pkg1==1")));
		assertTrue(callPackageRemoved(Arrays.asList("pkg1"), Arrays.asList("pkg1", "pkg2"),
				Arrays.asList("pkg1==1", "pkg2==1")));

		assertTrue(callPackageRemoved(Arrays.asList("pkg1"), Arrays.asList("pkg1=="), Arrays.asList("pkg1==1")));
		assertTrue(callPackageRemoved(Arrays.asList("pkg1=="), Arrays.asList("pkg1"), Arrays.asList("pkg1==1")));
		assertTrue(callPackageRemoved(Arrays.asList("==pkg1"), Arrays.asList("pkg1"), Arrays.asList("pkg1==1")));

		assertTrue(callPackageRemoved(Arrays.asList("pkg1==2"), Arrays.asList("pkg1==1"), Arrays.asList("pkg1==1")));
		assertTrue(callPackageRemoved(Arrays.asList("pkg1==2"), Arrays.asList("pkg1==1", "pkg2==1"),
				Arrays.asList("pkg1==1", "pkg2==1")));
		assertTrue(callPackageRemoved(Arrays.asList("pkg1==2"), Arrays.asList("pkg1", "pkg2"),
				Arrays.asList("pkg1==1", "pkg2==1")));
	}

	@Test
	public void venvContentsFormat() throws IOException, PackagesChangedException {
		TestLog log = new TestLog();
		Path tmpDir = Files.createTempDirectory("installAndLock");
		Path venvDir = tmpDir.resolve("venv");
		Path contents = venvDir.resolve("contents");
		deleteDirOnShutdown(tmpDir);

		Path lockFile = tmpDir.resolve("graalpy.lock");

		// 1a.) create venv
		createVenv(venvDir, "24.2.0", log, lockFile, "hello-world", "tiny-tiny");
		assertTrue(Files.exists(venvDir));
		checkVenvCreate(log.getOutput(), true);
		checkVenvContentsFile(contents, "24.2.0", "hello-world", "tiny-tiny");
		log.clearOutput();
		// 1b.) and patch venv contents with format as if from graalpy < 25.0.0
		// first line is version, all following lines are packages
		Files.write(contents, Arrays.asList("24.2.0", "hello-world", "tiny-tiny"), StandardOpenOption.CREATE,
				StandardOpenOption.TRUNCATE_EXISTING);

		// 2.) now again, all we are interested in, is that
		// - no error appears due to previous version contents format
		// - and contents are back as expected
		createVenv(venvDir, "25.0.0", log, lockFile, "hello-world", "tiny-tiny");
		assertTrue(Files.exists(venvDir));
		checkVenvCreate(log.getOutput(), true);
		checkVenvContentsFile(contents, "25.0.0", "hello-world", "tiny-tiny");
	}

	@Test
	public void differentPlatform() throws IOException, PackagesChangedException {
		TestLog log = new TestLog();
		Path tmpDir = Files.createTempDirectory("installAndLock");
		Path venvDir = tmpDir.resolve("venv");
		Path contents = venvDir.resolve("contents");
		deleteDirOnShutdown(tmpDir);

		Path lockFile = tmpDir.resolve("graalpy.lock");

		// 1a.) create venv
		createVenv(venvDir, "0.1", log, lockFile, "hello-world");
		assertTrue(Files.exists(venvDir));
		checkVenvCreate(log.getOutput(), true);
		checkVenvContentsFile(contents, "0.1", "hello-world");
		log.clearOutput();
		// 1b.) and patch venv contents with different platform
		List<String> lines = Files.readAllLines(contents).stream()
				.map(l -> l.startsWith("platform=") ? "platform=bogus" : l).collect(Collectors.toList());
		Files.write(contents, lines, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);

		// 2.) now again - venv is removed and newly created
		createVenv(venvDir, "0.1", log, lockFile, "hello-world");
		assertTrue(Files.exists(venvDir));
		checkVenvCreate(log.getOutput(), true);
		checkVenvContentsFile(contents, "0.1", "hello-world");
		assertThat(log.getOutput(), containsString("Reinstalling GraalPy venv created on"));
	}

	private static boolean callPackageRemoved(List<String> packages, List<String> contents, List<String> installed)
			throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
		Method m = VFSUtils.class.getDeclaredMethod("removedFromPluginPackages", List.class, List.class, List.class);
		m.setAccessible(true);
		return (boolean) m.invoke(VFSUtils.class, packages, contents, installed);
	}

	private static <T extends Throwable> void checkException(Class<T> exType, Executable c) {
		assertThrows(exType, c);
	}

	private static <T extends Throwable> void checkException(Class<T> exType, Executable c, String msg) {
		assertThrows(exType, c, msg);
	}

	private static void checkVenvCreate(String output, boolean b) {
		if (b) {
			assertTrue(output.contains("-m venv"));
			assertTrue(output.contains("-m ensurepip"));
		} else {
			assertFalse(output.contains("-m venv"));
			assertFalse(output.contains("-m ensurepip"));
		}
	}

	private static void checkInstalledPackages(Path instaledFile, String... packages) throws IOException {
		assertTrue(Files.exists(instaledFile));
		checkPackages(instaledFile, Files.readAllLines(instaledFile), packages);
	}

	private static void checkLockFile(Path lockFile, String[] inputPackages, String... installedPackages)
			throws IOException {
		assertTrue(Files.exists(lockFile));
		List<String> lines = Files.readAllLines(lockFile);
		List<String> header = createLockFileHeader("0.1", inputPackages);
		assertTrue(lines.size() >= header.size());
		for (int i = 0; i < header.size(); i++) {
			assertEquals(header.get(i), lines.get(i));
		}
		checkPackages(lockFile, lines, installedPackages);
	}

	private static void checkPackages(Path file, List<String> linesArg, String... packages) {
		List<String> lines = linesArg.stream().filter(line -> !line.trim().startsWith("#") && !line.trim().isEmpty())
				.toList();
		assertEquals(packages.length, lines.size());
		for (String pkg : packages) {
			boolean found = false;
			String pkgDef = pkg.contains("==") ? pkg : pkg + "==";
			for (String line : lines) {
				assert line.contains("==");
				if (line.startsWith(pkgDef)) {
					found = true;
					break;
				}
			}
			if (!found) {
				fail("file " + file + " does not contain package " + pkg);
			}
		}
	}

	private static void createVenv(Path venvDir, String graalPyVersion, TestLog log, String... packages)
			throws IOException, PackagesChangedException {
		EmbeddingTestUtils.createVenv(venvDir, graalPyVersion, log, packages);
	}

	private static void createVenv(Path venvDir, String graalPyVersion, TestLog log, Path lockFile, String... packages)
			throws IOException, PackagesChangedException {
		EmbeddingTestUtils.createVenv(venvDir, graalPyVersion, log, lockFile, MISSING_LOCK_FILE_WARNING, packages);
	}

	private static void checkVenvContentsFile(Path contents, String graalPyVersion, String... packages)
			throws IOException {
		assertTrue(Files.exists(contents));
		List<String> lines = Files.readAllLines(contents);

		Map<String, String> m = lines.stream().collect(Collectors.toMap(l -> {
			int idx = l.indexOf("=");
			return l.substring(0, idx);
		}, l -> {
			int idx = l.indexOf("=");
			return l.substring(idx + 1);
		}));

		assertEquals(graalPyVersion, m.get("version"));
		assertTrue(m.get("platform").contains(System.getProperty("os.name")));
		assertTrue(m.get("platform").contains(System.getProperty("os.arch")));
		List<String> pkgs = m.get("input_packages") != null
				? Arrays.asList(m.get("input_packages").split(","))
				: Collections.emptyList();
		assertEquals(packages.length, pkgs.size());
		if (!pkgs.containsAll(Arrays.asList(packages))) {
			fail(String.format("expected %s to contain all from %s", pkgs, Arrays.asList(packages)));
		}
	}
}
